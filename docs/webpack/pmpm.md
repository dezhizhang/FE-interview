# 为什么 pnpm 比 npm 快

`pnpm` 相比 `npm` 有显著的性能提升，原因主要体现在以下几个方面：

### 1. 磁盘空间优化

- **符号链接机制**：`pnpm` 使用符号链接（symlink）将所有的依赖包链接到 `node_modules`，而不是像 `npm` 那样将依赖包拷贝到每个项目中。依赖会安装在一个全局的存储位置（`.pnpm-store`），项目中的 `node_modules` 目录只是指向该存储的符号链接。

- **避免重复安装**：由于依赖的全局存储机制，多个项目之间可以共享相同版本的依赖。这样即便项目有相同的依赖，`pnpm` 也不会重复下载和安装，大大节省了磁盘空间。

### 2. 严格的依赖树结构

- **扁平化依赖树**：`pnpm` 不会像 `npm` 那样将所有依赖嵌套安装在 `node_modules` 中的子目录。相反，`pnpm` 使用一个严格的、非扁平化的依赖树结构，并通过符号链接使每个包准确定位其依赖关系。这样可以避免 `npm` 中可能出现的依赖冲突问题。

- **一致性更好**：`pnpm` 这种严格的结构确保了依赖关系的一致性，避免了某些依赖深度嵌套或重复安装的情况，这使得它更可靠和高效。

### 3. 快速的并行化处理

- **并行化安装**：`pnpm` 在安装过程中，采用了并行化的下载和安装机制。它可以同时下载多个依赖包，从而提高下载速度，尤其是在依赖包较多时，安装速度更快。

- **优化的文件系统操作**：`pnpm` 在处理文件系统时，减少了不必要的文件读写操作，进一步提升了性能。

### 4. 高效的缓存机制

- **强大的缓存功能**：`pnpm` 会将所有下载的依赖包存储到全局缓存中（`.pnpm-store`），以后在不同项目中再次使用相同版本的依赖时，无需重新下载，而是直接从缓存中读取。

- **本地和远程缓存结合**：即使在项目中删除了 `node_modules`，重新安装时，`pnpm` 依然可以从缓存中迅速恢复依赖，大幅提升安装速度。

### 5. 安全性和隔离性更高

- **非扁平化安装**：`pnpm` 的依赖包存储结构更严格，避免了 `npm` 的依赖提升问题。这确保了不同依赖包之间不会因为版本冲突而导致问题，增强了包管理的安全性。

### 6. 速度优化的对比

- **相较于 npm 和 yarn**，`pnpm` 的这些机制使得它在项目的首次安装和重复安装过程中表现出显著的速度优势。其缓存重用和并行处理极大提升了依赖包管理的效率，特别是在大型项目中优势明显。

### 总结

`pnpm` 通过符号链接、全局缓存、严格的依赖管理和并行处理等机制，显著提高了安装速度，优化了磁盘空间使用，减少了重复依赖安装，并提高了依赖管理的安全性和一致性。因此，`pnpm` 比 `npm` 更快、更高效，特别是在依赖复杂的大型项目中。
